2805는 이진 탐색 - do not solve
'''
통나무 중에 가장 낮은 것을 지표로 삼아서 그 위로 잘랐을 때
원하는 길이보다 짧으면 그 아래를 자르면 되는거고
원하는 기이보다 길면 그 위로 자르면 된다고 생각했다
하지만 이진 탐색보다 느리기 때문에 좋은 알고리즘은 아니다
'''

10828은 스택 문제 - solve
'''
strncmp와 사용해서 무슨 명령어가 들어왔는지 파악한 후 'if'문을 사용하여 해결 하였다
처음엔 scanf를 사용해서 명령어 입력을 받을려고 했는데 논리적 오류가 생겨 gets를 사용했다
의도적으로 top을 -1로 설정하여 실제로 스택하는 느낌으로 풀었다
마지막 부분에 버퍼문제를 파악하여 getchar()함수를 사용하여 버퍼를 비워줬다
'''

14501은 순환,반복 문제 - solve
'''
처음에는 순환으로 풀려다가 반복이 더 쉬울 것 같아서 반복으로 풀었다.
이 문제는 일단 순환으로 설명이 편하기 때문에 순화으로 설명하겠다

ex)
    1일차   2일차   3일차   4일차   5일차   6일차   7일차
T    3      5      1      1      2      4     2
P    10     20     10     20     15     40    200
결국에는 경우의 수 싸움이다
내가 만약 1일차를 선택했으면 다음 상담을 빨라도 4일차부터 시잘 할 수 있으므로 4~7일차 중에 어떤걸 선책해야 클지 알면 되는 것이다
4일차를 선택할 경우: 5~7일차 중에 더 큰것을 선택하면 된다
5일차를 선택할 경우: 7일차를 선택했을 때 얻을 수 있는 값을 알면된다 -> 선택할 수 없으므로 7일차에서 얻을 수 있는 금액은 0원이다
6일차를 선택할 경우: 전체 상담일자를 넘어버리기 때문에 선택 불가능하다 -> 얻을 수 있는 금액은 0원이다

따라서 1일차를 선택했을 때, 4일차를 선택하는 경우 그다음 5일차를 선택할 경우일 때가 가장 크다.
다음은 2일차를 선택했을 때... 쭉 구하다 보면 알 수 있다...
하지만 이 방법은 속도가 굉장히 느릴 수 있다. 왜냐면 n일차를 선택했을 때 가장 이득을 보는 함수를 bestPay메소드라 하면
bestPay(n+2),bestPay(n+3)...이 메소드 들이 중복으로 호출 될 수 있기 때문이다

출발을 마지막 일차로 정하고 역순으로 올라가면 중복으로 메소드를 호출할 필요가 없다
예를 들면...
7일차를 선택했다면 얻을 수 있는 최대 금액은 0원이다... (애초에 선택할 수 없는 것들은 최대 금액을 0으로 둔다)
6일차 ~ 최대 금액은 0원이다
5일차 ~ 자기 자신과 6~7일차 중 하나를 선택 시 얻을 수 있는 최대 금액을 합하면 된다. 즉 P[5] + 0이다
이렇게 하면 각 일차를 선택했을 때 얻을 수 있는 최대 금액을 알 수 있다
순환이랑 별 다를 것은 없지만 여러가지 변수를 생각하지 않아도 된다는 점이 장점이다
'''